// This file is generated by rust-protobuf 2.25.2. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `root.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_25_2;

#[derive(PartialEq,Clone,Default)]
pub struct Token {
    // message fields
    pub token: ::std::string::String,
    pub field_type: TokenType,
    // message oneof groups
    pub sub_type: ::std::option::Option<Token_oneof_sub_type>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Token {
    fn default() -> &'a Token {
        <Token as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum Token_oneof_sub_type {
    flag(FlagType),
    substitution(SubstitutionType),
    quantifiermodifier(QuantifierModifierType),
    anchor(AnchorType),
    character(::std::string::String),
    lookaround(LookaroundType),
    escape(EscapeType),
    groupref(GroupReferenceType),
    characterclass(CharacterClassType),
}

impl Token {
    pub fn new() -> Token {
        ::std::default::Default::default()
    }

    // string token = 8;


    pub fn get_token(&self) -> &str {
        &self.token
    }
    pub fn clear_token(&mut self) {
        self.token.clear();
    }

    // Param is passed by value, moved
    pub fn set_token(&mut self, v: ::std::string::String) {
        self.token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_token(&mut self) -> &mut ::std::string::String {
        &mut self.token
    }

    // Take field
    pub fn take_token(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.token, ::std::string::String::new())
    }

    // .TokenType type = 9;


    pub fn get_field_type(&self) -> TokenType {
        self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = TokenType::Flag;
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: TokenType) {
        self.field_type = v;
    }

    // .FlagType flag = 10;


    pub fn get_flag(&self) -> FlagType {
        match self.sub_type {
            ::std::option::Option::Some(Token_oneof_sub_type::flag(v)) => v,
            _ => FlagType::Ignore,
        }
    }
    pub fn clear_flag(&mut self) {
        self.sub_type = ::std::option::Option::None;
    }

    pub fn has_flag(&self) -> bool {
        match self.sub_type {
            ::std::option::Option::Some(Token_oneof_sub_type::flag(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_flag(&mut self, v: FlagType) {
        self.sub_type = ::std::option::Option::Some(Token_oneof_sub_type::flag(v))
    }

    // .SubstitutionType substitution = 11;


    pub fn get_substitution(&self) -> SubstitutionType {
        match self.sub_type {
            ::std::option::Option::Some(Token_oneof_sub_type::substitution(v)) => v,
            _ => SubstitutionType::Match,
        }
    }
    pub fn clear_substitution(&mut self) {
        self.sub_type = ::std::option::Option::None;
    }

    pub fn has_substitution(&self) -> bool {
        match self.sub_type {
            ::std::option::Option::Some(Token_oneof_sub_type::substitution(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_substitution(&mut self, v: SubstitutionType) {
        self.sub_type = ::std::option::Option::Some(Token_oneof_sub_type::substitution(v))
    }

    // .QuantifierModifierType quantifiermodifier = 12;


    pub fn get_quantifiermodifier(&self) -> QuantifierModifierType {
        match self.sub_type {
            ::std::option::Option::Some(Token_oneof_sub_type::quantifiermodifier(v)) => v,
            _ => QuantifierModifierType::Plus,
        }
    }
    pub fn clear_quantifiermodifier(&mut self) {
        self.sub_type = ::std::option::Option::None;
    }

    pub fn has_quantifiermodifier(&self) -> bool {
        match self.sub_type {
            ::std::option::Option::Some(Token_oneof_sub_type::quantifiermodifier(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_quantifiermodifier(&mut self, v: QuantifierModifierType) {
        self.sub_type = ::std::option::Option::Some(Token_oneof_sub_type::quantifiermodifier(v))
    }

    // .AnchorType anchor = 13;


    pub fn get_anchor(&self) -> AnchorType {
        match self.sub_type {
            ::std::option::Option::Some(Token_oneof_sub_type::anchor(v)) => v,
            _ => AnchorType::Beginning,
        }
    }
    pub fn clear_anchor(&mut self) {
        self.sub_type = ::std::option::Option::None;
    }

    pub fn has_anchor(&self) -> bool {
        match self.sub_type {
            ::std::option::Option::Some(Token_oneof_sub_type::anchor(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_anchor(&mut self, v: AnchorType) {
        self.sub_type = ::std::option::Option::Some(Token_oneof_sub_type::anchor(v))
    }

    // string character = 14;


    pub fn get_character(&self) -> &str {
        match self.sub_type {
            ::std::option::Option::Some(Token_oneof_sub_type::character(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_character(&mut self) {
        self.sub_type = ::std::option::Option::None;
    }

    pub fn has_character(&self) -> bool {
        match self.sub_type {
            ::std::option::Option::Some(Token_oneof_sub_type::character(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_character(&mut self, v: ::std::string::String) {
        self.sub_type = ::std::option::Option::Some(Token_oneof_sub_type::character(v))
    }

    // Mutable pointer to the field.
    pub fn mut_character(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(Token_oneof_sub_type::character(_)) = self.sub_type {
        } else {
            self.sub_type = ::std::option::Option::Some(Token_oneof_sub_type::character(::std::string::String::new()));
        }
        match self.sub_type {
            ::std::option::Option::Some(Token_oneof_sub_type::character(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_character(&mut self) -> ::std::string::String {
        if self.has_character() {
            match self.sub_type.take() {
                ::std::option::Option::Some(Token_oneof_sub_type::character(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // .LookaroundType lookaround = 15;


    pub fn get_lookaround(&self) -> LookaroundType {
        match self.sub_type {
            ::std::option::Option::Some(Token_oneof_sub_type::lookaround(v)) => v,
            _ => LookaroundType::PositiveLookahead,
        }
    }
    pub fn clear_lookaround(&mut self) {
        self.sub_type = ::std::option::Option::None;
    }

    pub fn has_lookaround(&self) -> bool {
        match self.sub_type {
            ::std::option::Option::Some(Token_oneof_sub_type::lookaround(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_lookaround(&mut self, v: LookaroundType) {
        self.sub_type = ::std::option::Option::Some(Token_oneof_sub_type::lookaround(v))
    }

    // .EscapeType escape = 16;


    pub fn get_escape(&self) -> EscapeType {
        match self.sub_type {
            ::std::option::Option::Some(Token_oneof_sub_type::escape(v)) => v,
            _ => EscapeType::UnicodeEscape,
        }
    }
    pub fn clear_escape(&mut self) {
        self.sub_type = ::std::option::Option::None;
    }

    pub fn has_escape(&self) -> bool {
        match self.sub_type {
            ::std::option::Option::Some(Token_oneof_sub_type::escape(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_escape(&mut self, v: EscapeType) {
        self.sub_type = ::std::option::Option::Some(Token_oneof_sub_type::escape(v))
    }

    // .GroupReferenceType groupref = 17;


    pub fn get_groupref(&self) -> GroupReferenceType {
        match self.sub_type {
            ::std::option::Option::Some(Token_oneof_sub_type::groupref(v)) => v,
            _ => GroupReferenceType::OpenCapture,
        }
    }
    pub fn clear_groupref(&mut self) {
        self.sub_type = ::std::option::Option::None;
    }

    pub fn has_groupref(&self) -> bool {
        match self.sub_type {
            ::std::option::Option::Some(Token_oneof_sub_type::groupref(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_groupref(&mut self, v: GroupReferenceType) {
        self.sub_type = ::std::option::Option::Some(Token_oneof_sub_type::groupref(v))
    }

    // .CharacterClassType characterclass = 18;


    pub fn get_characterclass(&self) -> CharacterClassType {
        match self.sub_type {
            ::std::option::Option::Some(Token_oneof_sub_type::characterclass(v)) => v,
            _ => CharacterClassType::OpenSet,
        }
    }
    pub fn clear_characterclass(&mut self) {
        self.sub_type = ::std::option::Option::None;
    }

    pub fn has_characterclass(&self) -> bool {
        match self.sub_type {
            ::std::option::Option::Some(Token_oneof_sub_type::characterclass(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_characterclass(&mut self, v: CharacterClassType) {
        self.sub_type = ::std::option::Option::Some(Token_oneof_sub_type::characterclass(v))
    }
}

impl ::protobuf::Message for Token {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                8 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.token)?;
                },
                9 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 9, &mut self.unknown_fields)?
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.sub_type = ::std::option::Option::Some(Token_oneof_sub_type::flag(is.read_enum()?));
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.sub_type = ::std::option::Option::Some(Token_oneof_sub_type::substitution(is.read_enum()?));
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.sub_type = ::std::option::Option::Some(Token_oneof_sub_type::quantifiermodifier(is.read_enum()?));
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.sub_type = ::std::option::Option::Some(Token_oneof_sub_type::anchor(is.read_enum()?));
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.sub_type = ::std::option::Option::Some(Token_oneof_sub_type::character(is.read_string()?));
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.sub_type = ::std::option::Option::Some(Token_oneof_sub_type::lookaround(is.read_enum()?));
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.sub_type = ::std::option::Option::Some(Token_oneof_sub_type::escape(is.read_enum()?));
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.sub_type = ::std::option::Option::Some(Token_oneof_sub_type::groupref(is.read_enum()?));
                },
                18 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.sub_type = ::std::option::Option::Some(Token_oneof_sub_type::characterclass(is.read_enum()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.token.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.token);
        }
        if self.field_type != TokenType::Flag {
            my_size += ::protobuf::rt::enum_size(9, self.field_type);
        }
        if let ::std::option::Option::Some(ref v) = self.sub_type {
            match v {
                &Token_oneof_sub_type::flag(v) => {
                    my_size += ::protobuf::rt::enum_size(10, v);
                },
                &Token_oneof_sub_type::substitution(v) => {
                    my_size += ::protobuf::rt::enum_size(11, v);
                },
                &Token_oneof_sub_type::quantifiermodifier(v) => {
                    my_size += ::protobuf::rt::enum_size(12, v);
                },
                &Token_oneof_sub_type::anchor(v) => {
                    my_size += ::protobuf::rt::enum_size(13, v);
                },
                &Token_oneof_sub_type::character(ref v) => {
                    my_size += ::protobuf::rt::string_size(14, &v);
                },
                &Token_oneof_sub_type::lookaround(v) => {
                    my_size += ::protobuf::rt::enum_size(15, v);
                },
                &Token_oneof_sub_type::escape(v) => {
                    my_size += ::protobuf::rt::enum_size(16, v);
                },
                &Token_oneof_sub_type::groupref(v) => {
                    my_size += ::protobuf::rt::enum_size(17, v);
                },
                &Token_oneof_sub_type::characterclass(v) => {
                    my_size += ::protobuf::rt::enum_size(18, v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.token.is_empty() {
            os.write_string(8, &self.token)?;
        }
        if self.field_type != TokenType::Flag {
            os.write_enum(9, ::protobuf::ProtobufEnum::value(&self.field_type))?;
        }
        if let ::std::option::Option::Some(ref v) = self.sub_type {
            match v {
                &Token_oneof_sub_type::flag(v) => {
                    os.write_enum(10, ::protobuf::ProtobufEnum::value(&v))?;
                },
                &Token_oneof_sub_type::substitution(v) => {
                    os.write_enum(11, ::protobuf::ProtobufEnum::value(&v))?;
                },
                &Token_oneof_sub_type::quantifiermodifier(v) => {
                    os.write_enum(12, ::protobuf::ProtobufEnum::value(&v))?;
                },
                &Token_oneof_sub_type::anchor(v) => {
                    os.write_enum(13, ::protobuf::ProtobufEnum::value(&v))?;
                },
                &Token_oneof_sub_type::character(ref v) => {
                    os.write_string(14, v)?;
                },
                &Token_oneof_sub_type::lookaround(v) => {
                    os.write_enum(15, ::protobuf::ProtobufEnum::value(&v))?;
                },
                &Token_oneof_sub_type::escape(v) => {
                    os.write_enum(16, ::protobuf::ProtobufEnum::value(&v))?;
                },
                &Token_oneof_sub_type::groupref(v) => {
                    os.write_enum(17, ::protobuf::ProtobufEnum::value(&v))?;
                },
                &Token_oneof_sub_type::characterclass(v) => {
                    os.write_enum(18, ::protobuf::ProtobufEnum::value(&v))?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Token {
        Token::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "token",
                |m: &Token| { &m.token },
                |m: &mut Token| { &mut m.token },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<TokenType>>(
                "type",
                |m: &Token| { &m.field_type },
                |m: &mut Token| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_enum_accessor::<_, FlagType>(
                "flag",
                Token::has_flag,
                Token::get_flag,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_enum_accessor::<_, SubstitutionType>(
                "substitution",
                Token::has_substitution,
                Token::get_substitution,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_enum_accessor::<_, QuantifierModifierType>(
                "quantifiermodifier",
                Token::has_quantifiermodifier,
                Token::get_quantifiermodifier,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_enum_accessor::<_, AnchorType>(
                "anchor",
                Token::has_anchor,
                Token::get_anchor,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "character",
                Token::has_character,
                Token::get_character,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_enum_accessor::<_, LookaroundType>(
                "lookaround",
                Token::has_lookaround,
                Token::get_lookaround,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_enum_accessor::<_, EscapeType>(
                "escape",
                Token::has_escape,
                Token::get_escape,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_enum_accessor::<_, GroupReferenceType>(
                "groupref",
                Token::has_groupref,
                Token::get_groupref,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_enum_accessor::<_, CharacterClassType>(
                "characterclass",
                Token::has_characterclass,
                Token::get_characterclass,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Token>(
                "Token",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Token {
        static instance: ::protobuf::rt::LazyV2<Token> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Token::new)
    }
}

impl ::protobuf::Clear for Token {
    fn clear(&mut self) {
        self.token.clear();
        self.field_type = TokenType::Flag;
        self.sub_type = ::std::option::Option::None;
        self.sub_type = ::std::option::Option::None;
        self.sub_type = ::std::option::Option::None;
        self.sub_type = ::std::option::Option::None;
        self.sub_type = ::std::option::Option::None;
        self.sub_type = ::std::option::Option::None;
        self.sub_type = ::std::option::Option::None;
        self.sub_type = ::std::option::Option::None;
        self.sub_type = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Token {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Token {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Expression {
    // message fields
    pub raw: ::std::string::String,
    pub tokens: ::protobuf::RepeatedField<Token>,
    pub expressions: ::protobuf::RepeatedField<Expression>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Expression {
    fn default() -> &'a Expression {
        <Expression as ::protobuf::Message>::default_instance()
    }
}

impl Expression {
    pub fn new() -> Expression {
        ::std::default::Default::default()
    }

    // string raw = 5;


    pub fn get_raw(&self) -> &str {
        &self.raw
    }
    pub fn clear_raw(&mut self) {
        self.raw.clear();
    }

    // Param is passed by value, moved
    pub fn set_raw(&mut self, v: ::std::string::String) {
        self.raw = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_raw(&mut self) -> &mut ::std::string::String {
        &mut self.raw
    }

    // Take field
    pub fn take_raw(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.raw, ::std::string::String::new())
    }

    // repeated .Token tokens = 6;


    pub fn get_tokens(&self) -> &[Token] {
        &self.tokens
    }
    pub fn clear_tokens(&mut self) {
        self.tokens.clear();
    }

    // Param is passed by value, moved
    pub fn set_tokens(&mut self, v: ::protobuf::RepeatedField<Token>) {
        self.tokens = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tokens(&mut self) -> &mut ::protobuf::RepeatedField<Token> {
        &mut self.tokens
    }

    // Take field
    pub fn take_tokens(&mut self) -> ::protobuf::RepeatedField<Token> {
        ::std::mem::replace(&mut self.tokens, ::protobuf::RepeatedField::new())
    }

    // repeated .Expression expressions = 7;


    pub fn get_expressions(&self) -> &[Expression] {
        &self.expressions
    }
    pub fn clear_expressions(&mut self) {
        self.expressions.clear();
    }

    // Param is passed by value, moved
    pub fn set_expressions(&mut self, v: ::protobuf::RepeatedField<Expression>) {
        self.expressions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_expressions(&mut self) -> &mut ::protobuf::RepeatedField<Expression> {
        &mut self.expressions
    }

    // Take field
    pub fn take_expressions(&mut self) -> ::protobuf::RepeatedField<Expression> {
        ::std::mem::replace(&mut self.expressions, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Expression {
    fn is_initialized(&self) -> bool {
        for v in &self.tokens {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.expressions {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.raw)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.tokens)?;
                },
                7 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.expressions)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.raw.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.raw);
        }
        for value in &self.tokens {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.expressions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.raw.is_empty() {
            os.write_string(5, &self.raw)?;
        }
        for v in &self.tokens {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.expressions {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Expression {
        Expression::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "raw",
                |m: &Expression| { &m.raw },
                |m: &mut Expression| { &mut m.raw },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Token>>(
                "tokens",
                |m: &Expression| { &m.tokens },
                |m: &mut Expression| { &mut m.tokens },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Expression>>(
                "expressions",
                |m: &Expression| { &m.expressions },
                |m: &mut Expression| { &mut m.expressions },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Expression>(
                "Expression",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Expression {
        static instance: ::protobuf::rt::LazyV2<Expression> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Expression::new)
    }
}

impl ::protobuf::Clear for Expression {
    fn clear(&mut self) {
        self.raw.clear();
        self.tokens.clear();
        self.expressions.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Expression {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Expression {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Root {
    // message fields
    pub file: ::std::string::String,
    pub language: SupportedLanguage,
    pub line_number: i32,
    pub expression: ::protobuf::SingularPtrField<Expression>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Root {
    fn default() -> &'a Root {
        <Root as ::protobuf::Message>::default_instance()
    }
}

impl Root {
    pub fn new() -> Root {
        ::std::default::Default::default()
    }

    // string file = 1;


    pub fn get_file(&self) -> &str {
        &self.file
    }
    pub fn clear_file(&mut self) {
        self.file.clear();
    }

    // Param is passed by value, moved
    pub fn set_file(&mut self, v: ::std::string::String) {
        self.file = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_file(&mut self) -> &mut ::std::string::String {
        &mut self.file
    }

    // Take field
    pub fn take_file(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.file, ::std::string::String::new())
    }

    // .SupportedLanguage language = 2;


    pub fn get_language(&self) -> SupportedLanguage {
        self.language
    }
    pub fn clear_language(&mut self) {
        self.language = SupportedLanguage::Python;
    }

    // Param is passed by value, moved
    pub fn set_language(&mut self, v: SupportedLanguage) {
        self.language = v;
    }

    // int32 line_number = 3;


    pub fn get_line_number(&self) -> i32 {
        self.line_number
    }
    pub fn clear_line_number(&mut self) {
        self.line_number = 0;
    }

    // Param is passed by value, moved
    pub fn set_line_number(&mut self, v: i32) {
        self.line_number = v;
    }

    // .Expression expression = 4;


    pub fn get_expression(&self) -> &Expression {
        self.expression.as_ref().unwrap_or_else(|| <Expression as ::protobuf::Message>::default_instance())
    }
    pub fn clear_expression(&mut self) {
        self.expression.clear();
    }

    pub fn has_expression(&self) -> bool {
        self.expression.is_some()
    }

    // Param is passed by value, moved
    pub fn set_expression(&mut self, v: Expression) {
        self.expression = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_expression(&mut self) -> &mut Expression {
        if self.expression.is_none() {
            self.expression.set_default();
        }
        self.expression.as_mut().unwrap()
    }

    // Take field
    pub fn take_expression(&mut self) -> Expression {
        self.expression.take().unwrap_or_else(|| Expression::new())
    }
}

impl ::protobuf::Message for Root {
    fn is_initialized(&self) -> bool {
        for v in &self.expression {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.file)?;
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.language, 2, &mut self.unknown_fields)?
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.line_number = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.expression)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.file.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.file);
        }
        if self.language != SupportedLanguage::Python {
            my_size += ::protobuf::rt::enum_size(2, self.language);
        }
        if self.line_number != 0 {
            my_size += ::protobuf::rt::value_size(3, self.line_number, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.expression.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.file.is_empty() {
            os.write_string(1, &self.file)?;
        }
        if self.language != SupportedLanguage::Python {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&self.language))?;
        }
        if self.line_number != 0 {
            os.write_int32(3, self.line_number)?;
        }
        if let Some(ref v) = self.expression.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Root {
        Root::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "file",
                |m: &Root| { &m.file },
                |m: &mut Root| { &mut m.file },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<SupportedLanguage>>(
                "language",
                |m: &Root| { &m.language },
                |m: &mut Root| { &mut m.language },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "line_number",
                |m: &Root| { &m.line_number },
                |m: &mut Root| { &mut m.line_number },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Expression>>(
                "expression",
                |m: &Root| { &m.expression },
                |m: &mut Root| { &mut m.expression },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Root>(
                "Root",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Root {
        static instance: ::protobuf::rt::LazyV2<Root> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Root::new)
    }
}

impl ::protobuf::Clear for Root {
    fn clear(&mut self) {
        self.file.clear();
        self.language = SupportedLanguage::Python;
        self.line_number = 0;
        self.expression.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Root {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Root {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Annotation {
    // message fields
    pub note: ::std::string::String,
    // message oneof groups
    pub relevant_entity: ::std::option::Option<Annotation_oneof_relevant_entity>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Annotation {
    fn default() -> &'a Annotation {
        <Annotation as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum Annotation_oneof_relevant_entity {
    entity(::std::string::String),
    token(Token),
    expression(Expression),
}

impl Annotation {
    pub fn new() -> Annotation {
        ::std::default::Default::default()
    }

    // string note = 1;


    pub fn get_note(&self) -> &str {
        &self.note
    }
    pub fn clear_note(&mut self) {
        self.note.clear();
    }

    // Param is passed by value, moved
    pub fn set_note(&mut self, v: ::std::string::String) {
        self.note = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_note(&mut self) -> &mut ::std::string::String {
        &mut self.note
    }

    // Take field
    pub fn take_note(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.note, ::std::string::String::new())
    }

    // string entity = 2;


    pub fn get_entity(&self) -> &str {
        match self.relevant_entity {
            ::std::option::Option::Some(Annotation_oneof_relevant_entity::entity(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_entity(&mut self) {
        self.relevant_entity = ::std::option::Option::None;
    }

    pub fn has_entity(&self) -> bool {
        match self.relevant_entity {
            ::std::option::Option::Some(Annotation_oneof_relevant_entity::entity(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_entity(&mut self, v: ::std::string::String) {
        self.relevant_entity = ::std::option::Option::Some(Annotation_oneof_relevant_entity::entity(v))
    }

    // Mutable pointer to the field.
    pub fn mut_entity(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(Annotation_oneof_relevant_entity::entity(_)) = self.relevant_entity {
        } else {
            self.relevant_entity = ::std::option::Option::Some(Annotation_oneof_relevant_entity::entity(::std::string::String::new()));
        }
        match self.relevant_entity {
            ::std::option::Option::Some(Annotation_oneof_relevant_entity::entity(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_entity(&mut self) -> ::std::string::String {
        if self.has_entity() {
            match self.relevant_entity.take() {
                ::std::option::Option::Some(Annotation_oneof_relevant_entity::entity(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // .Token token = 3;


    pub fn get_token(&self) -> &Token {
        match self.relevant_entity {
            ::std::option::Option::Some(Annotation_oneof_relevant_entity::token(ref v)) => v,
            _ => <Token as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_token(&mut self) {
        self.relevant_entity = ::std::option::Option::None;
    }

    pub fn has_token(&self) -> bool {
        match self.relevant_entity {
            ::std::option::Option::Some(Annotation_oneof_relevant_entity::token(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_token(&mut self, v: Token) {
        self.relevant_entity = ::std::option::Option::Some(Annotation_oneof_relevant_entity::token(v))
    }

    // Mutable pointer to the field.
    pub fn mut_token(&mut self) -> &mut Token {
        if let ::std::option::Option::Some(Annotation_oneof_relevant_entity::token(_)) = self.relevant_entity {
        } else {
            self.relevant_entity = ::std::option::Option::Some(Annotation_oneof_relevant_entity::token(Token::new()));
        }
        match self.relevant_entity {
            ::std::option::Option::Some(Annotation_oneof_relevant_entity::token(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_token(&mut self) -> Token {
        if self.has_token() {
            match self.relevant_entity.take() {
                ::std::option::Option::Some(Annotation_oneof_relevant_entity::token(v)) => v,
                _ => panic!(),
            }
        } else {
            Token::new()
        }
    }

    // .Expression expression = 4;


    pub fn get_expression(&self) -> &Expression {
        match self.relevant_entity {
            ::std::option::Option::Some(Annotation_oneof_relevant_entity::expression(ref v)) => v,
            _ => <Expression as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_expression(&mut self) {
        self.relevant_entity = ::std::option::Option::None;
    }

    pub fn has_expression(&self) -> bool {
        match self.relevant_entity {
            ::std::option::Option::Some(Annotation_oneof_relevant_entity::expression(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_expression(&mut self, v: Expression) {
        self.relevant_entity = ::std::option::Option::Some(Annotation_oneof_relevant_entity::expression(v))
    }

    // Mutable pointer to the field.
    pub fn mut_expression(&mut self) -> &mut Expression {
        if let ::std::option::Option::Some(Annotation_oneof_relevant_entity::expression(_)) = self.relevant_entity {
        } else {
            self.relevant_entity = ::std::option::Option::Some(Annotation_oneof_relevant_entity::expression(Expression::new()));
        }
        match self.relevant_entity {
            ::std::option::Option::Some(Annotation_oneof_relevant_entity::expression(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_expression(&mut self) -> Expression {
        if self.has_expression() {
            match self.relevant_entity.take() {
                ::std::option::Option::Some(Annotation_oneof_relevant_entity::expression(v)) => v,
                _ => panic!(),
            }
        } else {
            Expression::new()
        }
    }
}

impl ::protobuf::Message for Annotation {
    fn is_initialized(&self) -> bool {
        if let Some(Annotation_oneof_relevant_entity::token(ref v)) = self.relevant_entity {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Annotation_oneof_relevant_entity::expression(ref v)) = self.relevant_entity {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.note)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.relevant_entity = ::std::option::Option::Some(Annotation_oneof_relevant_entity::entity(is.read_string()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.relevant_entity = ::std::option::Option::Some(Annotation_oneof_relevant_entity::token(is.read_message()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.relevant_entity = ::std::option::Option::Some(Annotation_oneof_relevant_entity::expression(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.note.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.note);
        }
        if let ::std::option::Option::Some(ref v) = self.relevant_entity {
            match v {
                &Annotation_oneof_relevant_entity::entity(ref v) => {
                    my_size += ::protobuf::rt::string_size(2, &v);
                },
                &Annotation_oneof_relevant_entity::token(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Annotation_oneof_relevant_entity::expression(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.note.is_empty() {
            os.write_string(1, &self.note)?;
        }
        if let ::std::option::Option::Some(ref v) = self.relevant_entity {
            match v {
                &Annotation_oneof_relevant_entity::entity(ref v) => {
                    os.write_string(2, v)?;
                },
                &Annotation_oneof_relevant_entity::token(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Annotation_oneof_relevant_entity::expression(ref v) => {
                    os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Annotation {
        Annotation::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "note",
                |m: &Annotation| { &m.note },
                |m: &mut Annotation| { &mut m.note },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "entity",
                Annotation::has_entity,
                Annotation::get_entity,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Token>(
                "token",
                Annotation::has_token,
                Annotation::get_token,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Expression>(
                "expression",
                Annotation::has_expression,
                Annotation::get_expression,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Annotation>(
                "Annotation",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Annotation {
        static instance: ::protobuf::rt::LazyV2<Annotation> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Annotation::new)
    }
}

impl ::protobuf::Clear for Annotation {
    fn clear(&mut self) {
        self.note.clear();
        self.relevant_entity = ::std::option::Option::None;
        self.relevant_entity = ::std::option::Option::None;
        self.relevant_entity = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Annotation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Annotation {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Output {
    // message fields
    pub status: ::std::string::String,
    pub annotations: ::protobuf::RepeatedField<Annotation>,
    pub score: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Output {
    fn default() -> &'a Output {
        <Output as ::protobuf::Message>::default_instance()
    }
}

impl Output {
    pub fn new() -> Output {
        ::std::default::Default::default()
    }

    // string status = 1;


    pub fn get_status(&self) -> &str {
        &self.status
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: ::std::string::String) {
        self.status = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut ::std::string::String {
        &mut self.status
    }

    // Take field
    pub fn take_status(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.status, ::std::string::String::new())
    }

    // repeated .Annotation annotations = 2;


    pub fn get_annotations(&self) -> &[Annotation] {
        &self.annotations
    }
    pub fn clear_annotations(&mut self) {
        self.annotations.clear();
    }

    // Param is passed by value, moved
    pub fn set_annotations(&mut self, v: ::protobuf::RepeatedField<Annotation>) {
        self.annotations = v;
    }

    // Mutable pointer to the field.
    pub fn mut_annotations(&mut self) -> &mut ::protobuf::RepeatedField<Annotation> {
        &mut self.annotations
    }

    // Take field
    pub fn take_annotations(&mut self) -> ::protobuf::RepeatedField<Annotation> {
        ::std::mem::replace(&mut self.annotations, ::protobuf::RepeatedField::new())
    }

    // int32 score = 3;


    pub fn get_score(&self) -> i32 {
        self.score
    }
    pub fn clear_score(&mut self) {
        self.score = 0;
    }

    // Param is passed by value, moved
    pub fn set_score(&mut self, v: i32) {
        self.score = v;
    }
}

impl ::protobuf::Message for Output {
    fn is_initialized(&self) -> bool {
        for v in &self.annotations {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.status)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.annotations)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.score = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.status.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.status);
        }
        for value in &self.annotations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.score != 0 {
            my_size += ::protobuf::rt::value_size(3, self.score, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.status.is_empty() {
            os.write_string(1, &self.status)?;
        }
        for v in &self.annotations {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.score != 0 {
            os.write_int32(3, self.score)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Output {
        Output::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "status",
                |m: &Output| { &m.status },
                |m: &mut Output| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Annotation>>(
                "annotations",
                |m: &Output| { &m.annotations },
                |m: &mut Output| { &mut m.annotations },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "score",
                |m: &Output| { &m.score },
                |m: &mut Output| { &mut m.score },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Output>(
                "Output",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Output {
        static instance: ::protobuf::rt::LazyV2<Output> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Output::new)
    }
}

impl ::protobuf::Clear for Output {
    fn clear(&mut self) {
        self.status.clear();
        self.annotations.clear();
        self.score = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Output {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Output {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FileOutput {
    // message fields
    pub root: ::protobuf::SingularPtrField<Root>,
    pub outputs: ::protobuf::RepeatedField<Output>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FileOutput {
    fn default() -> &'a FileOutput {
        <FileOutput as ::protobuf::Message>::default_instance()
    }
}

impl FileOutput {
    pub fn new() -> FileOutput {
        ::std::default::Default::default()
    }

    // .Root root = 1;


    pub fn get_root(&self) -> &Root {
        self.root.as_ref().unwrap_or_else(|| <Root as ::protobuf::Message>::default_instance())
    }
    pub fn clear_root(&mut self) {
        self.root.clear();
    }

    pub fn has_root(&self) -> bool {
        self.root.is_some()
    }

    // Param is passed by value, moved
    pub fn set_root(&mut self, v: Root) {
        self.root = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_root(&mut self) -> &mut Root {
        if self.root.is_none() {
            self.root.set_default();
        }
        self.root.as_mut().unwrap()
    }

    // Take field
    pub fn take_root(&mut self) -> Root {
        self.root.take().unwrap_or_else(|| Root::new())
    }

    // repeated .Output outputs = 2;


    pub fn get_outputs(&self) -> &[Output] {
        &self.outputs
    }
    pub fn clear_outputs(&mut self) {
        self.outputs.clear();
    }

    // Param is passed by value, moved
    pub fn set_outputs(&mut self, v: ::protobuf::RepeatedField<Output>) {
        self.outputs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_outputs(&mut self) -> &mut ::protobuf::RepeatedField<Output> {
        &mut self.outputs
    }

    // Take field
    pub fn take_outputs(&mut self) -> ::protobuf::RepeatedField<Output> {
        ::std::mem::replace(&mut self.outputs, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for FileOutput {
    fn is_initialized(&self) -> bool {
        for v in &self.root {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.outputs {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.root)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.outputs)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.root.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.outputs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.root.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.outputs {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FileOutput {
        FileOutput::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Root>>(
                "root",
                |m: &FileOutput| { &m.root },
                |m: &mut FileOutput| { &mut m.root },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Output>>(
                "outputs",
                |m: &FileOutput| { &m.outputs },
                |m: &mut FileOutput| { &mut m.outputs },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<FileOutput>(
                "FileOutput",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static FileOutput {
        static instance: ::protobuf::rt::LazyV2<FileOutput> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FileOutput::new)
    }
}

impl ::protobuf::Clear for FileOutput {
    fn clear(&mut self) {
        self.root.clear();
        self.outputs.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FileOutput {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FileOutput {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FoundExpresssion {
    // message fields
    pub expression: ::std::string::String,
    pub file: ::std::string::String,
    pub line_number: i32,
    pub language: SupportedLanguage,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FoundExpresssion {
    fn default() -> &'a FoundExpresssion {
        <FoundExpresssion as ::protobuf::Message>::default_instance()
    }
}

impl FoundExpresssion {
    pub fn new() -> FoundExpresssion {
        ::std::default::Default::default()
    }

    // string expression = 1;


    pub fn get_expression(&self) -> &str {
        &self.expression
    }
    pub fn clear_expression(&mut self) {
        self.expression.clear();
    }

    // Param is passed by value, moved
    pub fn set_expression(&mut self, v: ::std::string::String) {
        self.expression = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_expression(&mut self) -> &mut ::std::string::String {
        &mut self.expression
    }

    // Take field
    pub fn take_expression(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.expression, ::std::string::String::new())
    }

    // string file = 2;


    pub fn get_file(&self) -> &str {
        &self.file
    }
    pub fn clear_file(&mut self) {
        self.file.clear();
    }

    // Param is passed by value, moved
    pub fn set_file(&mut self, v: ::std::string::String) {
        self.file = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_file(&mut self) -> &mut ::std::string::String {
        &mut self.file
    }

    // Take field
    pub fn take_file(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.file, ::std::string::String::new())
    }

    // int32 line_number = 3;


    pub fn get_line_number(&self) -> i32 {
        self.line_number
    }
    pub fn clear_line_number(&mut self) {
        self.line_number = 0;
    }

    // Param is passed by value, moved
    pub fn set_line_number(&mut self, v: i32) {
        self.line_number = v;
    }

    // .SupportedLanguage language = 4;


    pub fn get_language(&self) -> SupportedLanguage {
        self.language
    }
    pub fn clear_language(&mut self) {
        self.language = SupportedLanguage::Python;
    }

    // Param is passed by value, moved
    pub fn set_language(&mut self, v: SupportedLanguage) {
        self.language = v;
    }
}

impl ::protobuf::Message for FoundExpresssion {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.expression)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.file)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.line_number = tmp;
                },
                4 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.language, 4, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.expression.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.expression);
        }
        if !self.file.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.file);
        }
        if self.line_number != 0 {
            my_size += ::protobuf::rt::value_size(3, self.line_number, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.language != SupportedLanguage::Python {
            my_size += ::protobuf::rt::enum_size(4, self.language);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.expression.is_empty() {
            os.write_string(1, &self.expression)?;
        }
        if !self.file.is_empty() {
            os.write_string(2, &self.file)?;
        }
        if self.line_number != 0 {
            os.write_int32(3, self.line_number)?;
        }
        if self.language != SupportedLanguage::Python {
            os.write_enum(4, ::protobuf::ProtobufEnum::value(&self.language))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FoundExpresssion {
        FoundExpresssion::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "expression",
                |m: &FoundExpresssion| { &m.expression },
                |m: &mut FoundExpresssion| { &mut m.expression },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "file",
                |m: &FoundExpresssion| { &m.file },
                |m: &mut FoundExpresssion| { &mut m.file },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "line_number",
                |m: &FoundExpresssion| { &m.line_number },
                |m: &mut FoundExpresssion| { &mut m.line_number },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<SupportedLanguage>>(
                "language",
                |m: &FoundExpresssion| { &m.language },
                |m: &mut FoundExpresssion| { &mut m.language },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<FoundExpresssion>(
                "FoundExpresssion",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static FoundExpresssion {
        static instance: ::protobuf::rt::LazyV2<FoundExpresssion> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FoundExpresssion::new)
    }
}

impl ::protobuf::Clear for FoundExpresssion {
    fn clear(&mut self) {
        self.expression.clear();
        self.file.clear();
        self.line_number = 0;
        self.language = SupportedLanguage::Python;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FoundExpresssion {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FoundExpresssion {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum FlagType {
    Ignore = 0,
    Global = 1,
    Multiline = 2,
    Unicode = 3,
    Sticky = 4,
    Dotall = 5,
}

impl ::protobuf::ProtobufEnum for FlagType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<FlagType> {
        match value {
            0 => ::std::option::Option::Some(FlagType::Ignore),
            1 => ::std::option::Option::Some(FlagType::Global),
            2 => ::std::option::Option::Some(FlagType::Multiline),
            3 => ::std::option::Option::Some(FlagType::Unicode),
            4 => ::std::option::Option::Some(FlagType::Sticky),
            5 => ::std::option::Option::Some(FlagType::Dotall),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [FlagType] = &[
            FlagType::Ignore,
            FlagType::Global,
            FlagType::Multiline,
            FlagType::Unicode,
            FlagType::Sticky,
            FlagType::Dotall,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<FlagType>("FlagType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for FlagType {
}

impl ::std::default::Default for FlagType {
    fn default() -> Self {
        FlagType::Ignore
    }
}

impl ::protobuf::reflect::ProtobufValue for FlagType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum SubstitutionType {
    Match = 0,
    Capture = 1,
    BeforeMatch = 2,
    AfterMatch = 3,
    EscapedDollar = 4,
}

impl ::protobuf::ProtobufEnum for SubstitutionType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<SubstitutionType> {
        match value {
            0 => ::std::option::Option::Some(SubstitutionType::Match),
            1 => ::std::option::Option::Some(SubstitutionType::Capture),
            2 => ::std::option::Option::Some(SubstitutionType::BeforeMatch),
            3 => ::std::option::Option::Some(SubstitutionType::AfterMatch),
            4 => ::std::option::Option::Some(SubstitutionType::EscapedDollar),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [SubstitutionType] = &[
            SubstitutionType::Match,
            SubstitutionType::Capture,
            SubstitutionType::BeforeMatch,
            SubstitutionType::AfterMatch,
            SubstitutionType::EscapedDollar,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<SubstitutionType>("SubstitutionType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for SubstitutionType {
}

impl ::std::default::Default for SubstitutionType {
    fn default() -> Self {
        SubstitutionType::Match
    }
}

impl ::protobuf::reflect::ProtobufValue for SubstitutionType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum AnchorType {
    Beginning = 0,
    End = 1,
    WordBoundary = 2,
    NotWordBoundary = 3,
    ForwardSlash = 4,
}

impl ::protobuf::ProtobufEnum for AnchorType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<AnchorType> {
        match value {
            0 => ::std::option::Option::Some(AnchorType::Beginning),
            1 => ::std::option::Option::Some(AnchorType::End),
            2 => ::std::option::Option::Some(AnchorType::WordBoundary),
            3 => ::std::option::Option::Some(AnchorType::NotWordBoundary),
            4 => ::std::option::Option::Some(AnchorType::ForwardSlash),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [AnchorType] = &[
            AnchorType::Beginning,
            AnchorType::End,
            AnchorType::WordBoundary,
            AnchorType::NotWordBoundary,
            AnchorType::ForwardSlash,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<AnchorType>("AnchorType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for AnchorType {
}

impl ::std::default::Default for AnchorType {
    fn default() -> Self {
        AnchorType::Beginning
    }
}

impl ::protobuf::reflect::ProtobufValue for AnchorType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum QuantifierModifierType {
    Plus = 0,
    Star = 1,
    SpecifiedQuantifier = 2,
    Optional = 3,
    Lazy = 4,
    AlternationPipe = 5,
}

impl ::protobuf::ProtobufEnum for QuantifierModifierType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<QuantifierModifierType> {
        match value {
            0 => ::std::option::Option::Some(QuantifierModifierType::Plus),
            1 => ::std::option::Option::Some(QuantifierModifierType::Star),
            2 => ::std::option::Option::Some(QuantifierModifierType::SpecifiedQuantifier),
            3 => ::std::option::Option::Some(QuantifierModifierType::Optional),
            4 => ::std::option::Option::Some(QuantifierModifierType::Lazy),
            5 => ::std::option::Option::Some(QuantifierModifierType::AlternationPipe),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [QuantifierModifierType] = &[
            QuantifierModifierType::Plus,
            QuantifierModifierType::Star,
            QuantifierModifierType::SpecifiedQuantifier,
            QuantifierModifierType::Optional,
            QuantifierModifierType::Lazy,
            QuantifierModifierType::AlternationPipe,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<QuantifierModifierType>("QuantifierModifierType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for QuantifierModifierType {
}

impl ::std::default::Default for QuantifierModifierType {
    fn default() -> Self {
        QuantifierModifierType::Plus
    }
}

impl ::protobuf::reflect::ProtobufValue for QuantifierModifierType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum LookaroundType {
    PositiveLookahead = 0,
    NegativeLookahead = 1,
    PositiveLookbehind = 2,
    NegativeLookbehind = 3,
}

impl ::protobuf::ProtobufEnum for LookaroundType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<LookaroundType> {
        match value {
            0 => ::std::option::Option::Some(LookaroundType::PositiveLookahead),
            1 => ::std::option::Option::Some(LookaroundType::NegativeLookahead),
            2 => ::std::option::Option::Some(LookaroundType::PositiveLookbehind),
            3 => ::std::option::Option::Some(LookaroundType::NegativeLookbehind),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [LookaroundType] = &[
            LookaroundType::PositiveLookahead,
            LookaroundType::NegativeLookahead,
            LookaroundType::PositiveLookbehind,
            LookaroundType::NegativeLookbehind,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<LookaroundType>("LookaroundType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for LookaroundType {
}

impl ::std::default::Default for LookaroundType {
    fn default() -> Self {
        LookaroundType::PositiveLookahead
    }
}

impl ::protobuf::reflect::ProtobufValue for LookaroundType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum EscapeType {
    UnicodeEscape = 0,
    Octal = 1,
    Hexadecimal = 2,
    Reserved = 3,
    Control = 4,
    Tab = 5,
    Newline = 6,
    VerticalTab = 7,
    FormFeed = 8,
    CarriageReturn = 9,
    Null = 10,
}

impl ::protobuf::ProtobufEnum for EscapeType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EscapeType> {
        match value {
            0 => ::std::option::Option::Some(EscapeType::UnicodeEscape),
            1 => ::std::option::Option::Some(EscapeType::Octal),
            2 => ::std::option::Option::Some(EscapeType::Hexadecimal),
            3 => ::std::option::Option::Some(EscapeType::Reserved),
            4 => ::std::option::Option::Some(EscapeType::Control),
            5 => ::std::option::Option::Some(EscapeType::Tab),
            6 => ::std::option::Option::Some(EscapeType::Newline),
            7 => ::std::option::Option::Some(EscapeType::VerticalTab),
            8 => ::std::option::Option::Some(EscapeType::FormFeed),
            9 => ::std::option::Option::Some(EscapeType::CarriageReturn),
            10 => ::std::option::Option::Some(EscapeType::Null),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [EscapeType] = &[
            EscapeType::UnicodeEscape,
            EscapeType::Octal,
            EscapeType::Hexadecimal,
            EscapeType::Reserved,
            EscapeType::Control,
            EscapeType::Tab,
            EscapeType::Newline,
            EscapeType::VerticalTab,
            EscapeType::FormFeed,
            EscapeType::CarriageReturn,
            EscapeType::Null,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<EscapeType>("EscapeType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for EscapeType {
}

impl ::std::default::Default for EscapeType {
    fn default() -> Self {
        EscapeType::UnicodeEscape
    }
}

impl ::protobuf::reflect::ProtobufValue for EscapeType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum GroupReferenceType {
    OpenCapture = 0,
    CloseCapture = 1,
    GroupName = 2,
    NumericReference = 3,
    NonCapturing = 4,
}

impl ::protobuf::ProtobufEnum for GroupReferenceType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<GroupReferenceType> {
        match value {
            0 => ::std::option::Option::Some(GroupReferenceType::OpenCapture),
            1 => ::std::option::Option::Some(GroupReferenceType::CloseCapture),
            2 => ::std::option::Option::Some(GroupReferenceType::GroupName),
            3 => ::std::option::Option::Some(GroupReferenceType::NumericReference),
            4 => ::std::option::Option::Some(GroupReferenceType::NonCapturing),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [GroupReferenceType] = &[
            GroupReferenceType::OpenCapture,
            GroupReferenceType::CloseCapture,
            GroupReferenceType::GroupName,
            GroupReferenceType::NumericReference,
            GroupReferenceType::NonCapturing,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<GroupReferenceType>("GroupReferenceType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for GroupReferenceType {
}

impl ::std::default::Default for GroupReferenceType {
    fn default() -> Self {
        GroupReferenceType::OpenCapture
    }
}

impl ::protobuf::reflect::ProtobufValue for GroupReferenceType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CharacterClassType {
    OpenSet = 0,
    CloseSet = 1,
    SetNegation = 2,
    InclusiveSet = 3,
    RangeSet = 4,
    Dot = 5,
    Word = 6,
    NotWord = 7,
    Digit = 8,
    NotDigit = 9,
    Whitespace = 10,
    NotWhitespace = 11,
    UnicodePropertyEscape = 12,
    NotUnicodePropertyEscape = 13,
    AtomicGroup = 14,
}

impl ::protobuf::ProtobufEnum for CharacterClassType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CharacterClassType> {
        match value {
            0 => ::std::option::Option::Some(CharacterClassType::OpenSet),
            1 => ::std::option::Option::Some(CharacterClassType::CloseSet),
            2 => ::std::option::Option::Some(CharacterClassType::SetNegation),
            3 => ::std::option::Option::Some(CharacterClassType::InclusiveSet),
            4 => ::std::option::Option::Some(CharacterClassType::RangeSet),
            5 => ::std::option::Option::Some(CharacterClassType::Dot),
            6 => ::std::option::Option::Some(CharacterClassType::Word),
            7 => ::std::option::Option::Some(CharacterClassType::NotWord),
            8 => ::std::option::Option::Some(CharacterClassType::Digit),
            9 => ::std::option::Option::Some(CharacterClassType::NotDigit),
            10 => ::std::option::Option::Some(CharacterClassType::Whitespace),
            11 => ::std::option::Option::Some(CharacterClassType::NotWhitespace),
            12 => ::std::option::Option::Some(CharacterClassType::UnicodePropertyEscape),
            13 => ::std::option::Option::Some(CharacterClassType::NotUnicodePropertyEscape),
            14 => ::std::option::Option::Some(CharacterClassType::AtomicGroup),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CharacterClassType] = &[
            CharacterClassType::OpenSet,
            CharacterClassType::CloseSet,
            CharacterClassType::SetNegation,
            CharacterClassType::InclusiveSet,
            CharacterClassType::RangeSet,
            CharacterClassType::Dot,
            CharacterClassType::Word,
            CharacterClassType::NotWord,
            CharacterClassType::Digit,
            CharacterClassType::NotDigit,
            CharacterClassType::Whitespace,
            CharacterClassType::NotWhitespace,
            CharacterClassType::UnicodePropertyEscape,
            CharacterClassType::NotUnicodePropertyEscape,
            CharacterClassType::AtomicGroup,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<CharacterClassType>("CharacterClassType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for CharacterClassType {
}

impl ::std::default::Default for CharacterClassType {
    fn default() -> Self {
        CharacterClassType::OpenSet
    }
}

impl ::protobuf::reflect::ProtobufValue for CharacterClassType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum TokenType {
    Flag = 0,
    Substitution = 1,
    QuantifierModifier = 2,
    Anchor = 3,
    GroupReference = 4,
    Character = 5,
    Lookaround = 6,
    Escape = 7,
    CharacterClass = 8,
}

impl ::protobuf::ProtobufEnum for TokenType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<TokenType> {
        match value {
            0 => ::std::option::Option::Some(TokenType::Flag),
            1 => ::std::option::Option::Some(TokenType::Substitution),
            2 => ::std::option::Option::Some(TokenType::QuantifierModifier),
            3 => ::std::option::Option::Some(TokenType::Anchor),
            4 => ::std::option::Option::Some(TokenType::GroupReference),
            5 => ::std::option::Option::Some(TokenType::Character),
            6 => ::std::option::Option::Some(TokenType::Lookaround),
            7 => ::std::option::Option::Some(TokenType::Escape),
            8 => ::std::option::Option::Some(TokenType::CharacterClass),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [TokenType] = &[
            TokenType::Flag,
            TokenType::Substitution,
            TokenType::QuantifierModifier,
            TokenType::Anchor,
            TokenType::GroupReference,
            TokenType::Character,
            TokenType::Lookaround,
            TokenType::Escape,
            TokenType::CharacterClass,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<TokenType>("TokenType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for TokenType {
}

impl ::std::default::Default for TokenType {
    fn default() -> Self {
        TokenType::Flag
    }
}

impl ::protobuf::reflect::ProtobufValue for TokenType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum SupportedLanguage {
    Python = 0,
    JavaScript = 1,
    Java = 2,
    Rust = 3,
    Golang = 4,
    PHP = 5,
    Ruby = 6,
}

impl ::protobuf::ProtobufEnum for SupportedLanguage {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<SupportedLanguage> {
        match value {
            0 => ::std::option::Option::Some(SupportedLanguage::Python),
            1 => ::std::option::Option::Some(SupportedLanguage::JavaScript),
            2 => ::std::option::Option::Some(SupportedLanguage::Java),
            3 => ::std::option::Option::Some(SupportedLanguage::Rust),
            4 => ::std::option::Option::Some(SupportedLanguage::Golang),
            5 => ::std::option::Option::Some(SupportedLanguage::PHP),
            6 => ::std::option::Option::Some(SupportedLanguage::Ruby),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [SupportedLanguage] = &[
            SupportedLanguage::Python,
            SupportedLanguage::JavaScript,
            SupportedLanguage::Java,
            SupportedLanguage::Rust,
            SupportedLanguage::Golang,
            SupportedLanguage::PHP,
            SupportedLanguage::Ruby,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<SupportedLanguage>("SupportedLanguage", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for SupportedLanguage {
}

impl ::std::default::Default for SupportedLanguage {
    fn default() -> Self {
        SupportedLanguage::Python
    }
}

impl ::protobuf::reflect::ProtobufValue for SupportedLanguage {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\nroot.proto\"\x81\x04\n\x05Token\x12\x14\n\x05token\x18\x08\x20\x01(\
    \tR\x05token\x12\x1e\n\x04type\x18\t\x20\x01(\x0e2\n.TokenTypeR\x04type\
    \x12\x1f\n\x04flag\x18\n\x20\x01(\x0e2\t.FlagTypeH\0R\x04flag\x127\n\x0c\
    substitution\x18\x0b\x20\x01(\x0e2\x11.SubstitutionTypeH\0R\x0csubstitut\
    ion\x12I\n\x12quantifiermodifier\x18\x0c\x20\x01(\x0e2\x17.QuantifierMod\
    ifierTypeH\0R\x12quantifiermodifier\x12%\n\x06anchor\x18\r\x20\x01(\x0e2\
    \x0b.AnchorTypeH\0R\x06anchor\x12\x1e\n\tcharacter\x18\x0e\x20\x01(\tH\0\
    R\tcharacter\x121\n\nlookaround\x18\x0f\x20\x01(\x0e2\x0f.LookaroundType\
    H\0R\nlookaround\x12%\n\x06escape\x18\x10\x20\x01(\x0e2\x0b.EscapeTypeH\
    \0R\x06escape\x121\n\x08groupref\x18\x11\x20\x01(\x0e2\x13.GroupReferenc\
    eTypeH\0R\x08groupref\x12=\n\x0echaracterclass\x18\x12\x20\x01(\x0e2\x13\
    .CharacterClassTypeH\0R\x0echaracterclassB\n\n\x08sub_type\"m\n\nExpress\
    ion\x12\x10\n\x03raw\x18\x05\x20\x01(\tR\x03raw\x12\x1e\n\x06tokens\x18\
    \x06\x20\x03(\x0b2\x06.TokenR\x06tokens\x12-\n\x0bexpressions\x18\x07\
    \x20\x03(\x0b2\x0b.ExpressionR\x0bexpressions\"\x98\x01\n\x04Root\x12\
    \x12\n\x04file\x18\x01\x20\x01(\tR\x04file\x12.\n\x08language\x18\x02\
    \x20\x01(\x0e2\x12.SupportedLanguageR\x08language\x12\x1f\n\x0bline_numb\
    er\x18\x03\x20\x01(\x05R\nlineNumber\x12+\n\nexpression\x18\x04\x20\x01(\
    \x0b2\x0b.ExpressionR\nexpression\"\x9c\x01\n\nAnnotation\x12\x12\n\x04n\
    ote\x18\x01\x20\x01(\tR\x04note\x12\x18\n\x06entity\x18\x02\x20\x01(\tH\
    \0R\x06entity\x12\x1e\n\x05token\x18\x03\x20\x01(\x0b2\x06.TokenH\0R\x05\
    token\x12-\n\nexpression\x18\x04\x20\x01(\x0b2\x0b.ExpressionH\0R\nexpre\
    ssionB\x11\n\x0frelevant_entity\"e\n\x06Output\x12\x16\n\x06status\x18\
    \x01\x20\x01(\tR\x06status\x12-\n\x0bannotations\x18\x02\x20\x03(\x0b2\
    \x0b.AnnotationR\x0bannotations\x12\x14\n\x05score\x18\x03\x20\x01(\x05R\
    \x05score\"J\n\nFileOutput\x12\x19\n\x04root\x18\x01\x20\x01(\x0b2\x05.R\
    ootR\x04root\x12!\n\x07outputs\x18\x02\x20\x03(\x0b2\x07.OutputR\x07outp\
    uts\"\x97\x01\n\x10FoundExpresssion\x12\x1e\n\nexpression\x18\x01\x20\
    \x01(\tR\nexpression\x12\x12\n\x04file\x18\x02\x20\x01(\tR\x04file\x12\
    \x1f\n\x0bline_number\x18\x03\x20\x01(\x05R\nlineNumber\x12.\n\x08langua\
    ge\x18\x04\x20\x01(\x0e2\x12.SupportedLanguageR\x08language*V\n\x08FlagT\
    ype\x12\n\n\x06Ignore\x10\0\x12\n\n\x06Global\x10\x01\x12\r\n\tMultiline\
    \x10\x02\x12\x0b\n\x07Unicode\x10\x03\x12\n\n\x06Sticky\x10\x04\x12\n\n\
    \x06Dotall\x10\x05*^\n\x10SubstitutionType\x12\t\n\x05Match\x10\0\x12\
    \x0b\n\x07Capture\x10\x01\x12\x0f\n\x0bBeforeMatch\x10\x02\x12\x0e\n\nAf\
    terMatch\x10\x03\x12\x11\n\rEscapedDollar\x10\x04*]\n\nAnchorType\x12\r\
    \n\tBeginning\x10\0\x12\x07\n\x03End\x10\x01\x12\x10\n\x0cWordBoundary\
    \x10\x02\x12\x13\n\x0fNotWordBoundary\x10\x03\x12\x10\n\x0cForwardSlash\
    \x10\x04*r\n\x16QuantifierModifierType\x12\x08\n\x04Plus\x10\0\x12\x08\n\
    \x04Star\x10\x01\x12\x17\n\x13SpecifiedQuantifier\x10\x02\x12\x0c\n\x08O\
    ptional\x10\x03\x12\x08\n\x04Lazy\x10\x04\x12\x13\n\x0fAlternationPipe\
    \x10\x05*n\n\x0eLookaroundType\x12\x15\n\x11PositiveLookahead\x10\0\x12\
    \x15\n\x11NegativeLookahead\x10\x01\x12\x16\n\x12PositiveLookbehind\x10\
    \x02\x12\x16\n\x12NegativeLookbehind\x10\x03*\xa9\x01\n\nEscapeType\x12\
    \x11\n\rUnicodeEscape\x10\0\x12\t\n\x05Octal\x10\x01\x12\x0f\n\x0bHexade\
    cimal\x10\x02\x12\x0c\n\x08Reserved\x10\x03\x12\x0b\n\x07Control\x10\x04\
    \x12\x07\n\x03Tab\x10\x05\x12\x0b\n\x07Newline\x10\x06\x12\x0f\n\x0bVert\
    icalTab\x10\x07\x12\x0c\n\x08FormFeed\x10\x08\x12\x12\n\x0eCarriageRetur\
    n\x10\t\x12\x08\n\x04Null\x10\n*n\n\x12GroupReferenceType\x12\x0f\n\x0bO\
    penCapture\x10\0\x12\x10\n\x0cCloseCapture\x10\x01\x12\r\n\tGroupName\
    \x10\x02\x12\x14\n\x10NumericReference\x10\x03\x12\x10\n\x0cNonCapturing\
    \x10\x04*\x86\x02\n\x12CharacterClassType\x12\x0b\n\x07OpenSet\x10\0\x12\
    \x0c\n\x08CloseSet\x10\x01\x12\x0f\n\x0bSetNegation\x10\x02\x12\x10\n\
    \x0cInclusiveSet\x10\x03\x12\x0c\n\x08RangeSet\x10\x04\x12\x07\n\x03Dot\
    \x10\x05\x12\x08\n\x04Word\x10\x06\x12\x0b\n\x07NotWord\x10\x07\x12\t\n\
    \x05Digit\x10\x08\x12\x0c\n\x08NotDigit\x10\t\x12\x0e\n\nWhitespace\x10\
    \n\x12\x11\n\rNotWhitespace\x10\x0b\x12\x19\n\x15UnicodePropertyEscape\
    \x10\x0c\x12\x1c\n\x18NotUnicodePropertyEscape\x10\r\x12\x0f\n\x0bAtomic\
    Group\x10\x0e*\x9e\x01\n\tTokenType\x12\x08\n\x04Flag\x10\0\x12\x10\n\
    \x0cSubstitution\x10\x01\x12\x16\n\x12QuantifierModifier\x10\x02\x12\n\n\
    \x06Anchor\x10\x03\x12\x12\n\x0eGroupReference\x10\x04\x12\r\n\tCharacte\
    r\x10\x05\x12\x0e\n\nLookaround\x10\x06\x12\n\n\x06Escape\x10\x07\x12\
    \x12\n\x0eCharacterClass\x10\x08*b\n\x11SupportedLanguage\x12\n\n\x06Pyt\
    hon\x10\0\x12\x0e\n\nJavaScript\x10\x01\x12\x08\n\x04Java\x10\x02\x12\
    \x08\n\x04Rust\x10\x03\x12\n\n\x06Golang\x10\x04\x12\x07\n\x03PHP\x10\
    \x05\x12\x08\n\x04Ruby\x10\x06J\xdd/\n\x07\x12\x05\0\0\xa3\x01\x01\n\x08\
    \n\x01\x0c\x12\x03\0\0\x10\n\n\n\x02\x05\0\x12\x04\x02\0\t\x01\n\n\n\x03\
    \x05\0\x01\x12\x03\x02\x05\r\n\x0b\n\x04\x05\0\x02\0\x12\x03\x03\x04\x0f\
    \n\x0c\n\x05\x05\0\x02\0\x01\x12\x03\x03\x04\n\n\x0c\n\x05\x05\0\x02\0\
    \x02\x12\x03\x03\r\x0e\n\x0b\n\x04\x05\0\x02\x01\x12\x03\x04\x04\x0f\n\
    \x0c\n\x05\x05\0\x02\x01\x01\x12\x03\x04\x04\n\n\x0c\n\x05\x05\0\x02\x01\
    \x02\x12\x03\x04\r\x0e\n\x0b\n\x04\x05\0\x02\x02\x12\x03\x05\x04\x12\n\
    \x0c\n\x05\x05\0\x02\x02\x01\x12\x03\x05\x04\r\n\x0c\n\x05\x05\0\x02\x02\
    \x02\x12\x03\x05\x10\x11\n\x0b\n\x04\x05\0\x02\x03\x12\x03\x06\x04\x10\n\
    \x0c\n\x05\x05\0\x02\x03\x01\x12\x03\x06\x04\x0b\n\x0c\n\x05\x05\0\x02\
    \x03\x02\x12\x03\x06\x0e\x0f\n\x0b\n\x04\x05\0\x02\x04\x12\x03\x07\x04\
    \x0f\n\x0c\n\x05\x05\0\x02\x04\x01\x12\x03\x07\x04\n\n\x0c\n\x05\x05\0\
    \x02\x04\x02\x12\x03\x07\r\x0e\n\x0b\n\x04\x05\0\x02\x05\x12\x03\x08\x04\
    \x0f\n\x0c\n\x05\x05\0\x02\x05\x01\x12\x03\x08\x04\n\n\x0c\n\x05\x05\0\
    \x02\x05\x02\x12\x03\x08\r\x0e\n\n\n\x02\x05\x01\x12\x04\x0b\0\x11\x01\n\
    \n\n\x03\x05\x01\x01\x12\x03\x0b\x05\x15\n\x0b\n\x04\x05\x01\x02\0\x12\
    \x03\x0c\x04\x0e\n\x0c\n\x05\x05\x01\x02\0\x01\x12\x03\x0c\x04\t\n\x0c\n\
    \x05\x05\x01\x02\0\x02\x12\x03\x0c\x0c\r\n\x0b\n\x04\x05\x01\x02\x01\x12\
    \x03\r\x04\x10\n\x0c\n\x05\x05\x01\x02\x01\x01\x12\x03\r\x04\x0b\n\x0c\n\
    \x05\x05\x01\x02\x01\x02\x12\x03\r\x0e\x0f\n\x0b\n\x04\x05\x01\x02\x02\
    \x12\x03\x0e\x04\x14\n\x0c\n\x05\x05\x01\x02\x02\x01\x12\x03\x0e\x04\x0f\
    \n\x0c\n\x05\x05\x01\x02\x02\x02\x12\x03\x0e\x12\x13\n\x0b\n\x04\x05\x01\
    \x02\x03\x12\x03\x0f\x04\x13\n\x0c\n\x05\x05\x01\x02\x03\x01\x12\x03\x0f\
    \x04\x0e\n\x0c\n\x05\x05\x01\x02\x03\x02\x12\x03\x0f\x11\x12\n\x0b\n\x04\
    \x05\x01\x02\x04\x12\x03\x10\x04\x16\n\x0c\n\x05\x05\x01\x02\x04\x01\x12\
    \x03\x10\x04\x11\n\x0c\n\x05\x05\x01\x02\x04\x02\x12\x03\x10\x14\x15\n\n\
    \n\x02\x05\x02\x12\x04\x13\0\x19\x01\n\n\n\x03\x05\x02\x01\x12\x03\x13\
    \x05\x0f\n\x0b\n\x04\x05\x02\x02\0\x12\x03\x14\x04\x12\n\x0c\n\x05\x05\
    \x02\x02\0\x01\x12\x03\x14\x04\r\n\x0c\n\x05\x05\x02\x02\0\x02\x12\x03\
    \x14\x10\x11\n\x0b\n\x04\x05\x02\x02\x01\x12\x03\x15\x04\x0c\n\x0c\n\x05\
    \x05\x02\x02\x01\x01\x12\x03\x15\x04\x07\n\x0c\n\x05\x05\x02\x02\x01\x02\
    \x12\x03\x15\n\x0b\n\x0b\n\x04\x05\x02\x02\x02\x12\x03\x16\x04\x15\n\x0c\
    \n\x05\x05\x02\x02\x02\x01\x12\x03\x16\x04\x10\n\x0c\n\x05\x05\x02\x02\
    \x02\x02\x12\x03\x16\x13\x14\n\x0b\n\x04\x05\x02\x02\x03\x12\x03\x17\x04\
    \x18\n\x0c\n\x05\x05\x02\x02\x03\x01\x12\x03\x17\x04\x13\n\x0c\n\x05\x05\
    \x02\x02\x03\x02\x12\x03\x17\x16\x17\nG\n\x04\x05\x02\x02\x04\x12\x03\
    \x18\x04\x15\":\x20/.../\x20means\x20the\x20string\x20in\x20between\x20i\
    s\x20regex\x20(js\x20specific)\n\n\x0c\n\x05\x05\x02\x02\x04\x01\x12\x03\
    \x18\x04\x10\n\x0c\n\x05\x05\x02\x02\x04\x02\x12\x03\x18\x13\x14\n\n\n\
    \x02\x05\x03\x12\x04\x1b\0\"\x01\n\n\n\x03\x05\x03\x01\x12\x03\x1b\x05\
    \x1b\n\x0b\n\x04\x05\x03\x02\0\x12\x03\x1c\x04\r\n\x0c\n\x05\x05\x03\x02\
    \0\x01\x12\x03\x1c\x04\x08\n\x0c\n\x05\x05\x03\x02\0\x02\x12\x03\x1c\x0b\
    \x0c\n\x0b\n\x04\x05\x03\x02\x01\x12\x03\x1d\x04\r\n\x0c\n\x05\x05\x03\
    \x02\x01\x01\x12\x03\x1d\x04\x08\n\x0c\n\x05\x05\x03\x02\x01\x02\x12\x03\
    \x1d\x0b\x0c\n#\n\x04\x05\x03\x02\x02\x12\x03\x1e\x04\x1c\"\x16\x20Somet\
    hing\x20like\x20{1,3}\n\n\x0c\n\x05\x05\x03\x02\x02\x01\x12\x03\x1e\x04\
    \x17\n\x0c\n\x05\x05\x03\x02\x02\x02\x12\x03\x1e\x1a\x1b\n\x0b\n\x04\x05\
    \x03\x02\x03\x12\x03\x1f\x04\x11\n\x0c\n\x05\x05\x03\x02\x03\x01\x12\x03\
    \x1f\x04\x0c\n\x0c\n\x05\x05\x03\x02\x03\x02\x12\x03\x1f\x0f\x10\n\x0b\n\
    \x04\x05\x03\x02\x04\x12\x03\x20\x04\r\n\x0c\n\x05\x05\x03\x02\x04\x01\
    \x12\x03\x20\x04\x08\n\x0c\n\x05\x05\x03\x02\x04\x02\x12\x03\x20\x0b\x0c\
    \n.\n\x04\x05\x03\x02\x05\x12\x03!\x04\x18\"!\x20the\x20usage\x20of\x20|\
    \x20as\x20an\x20alternator\n\n\x0c\n\x05\x05\x03\x02\x05\x01\x12\x03!\
    \x04\x13\n\x0c\n\x05\x05\x03\x02\x05\x02\x12\x03!\x16\x17\n\n\n\x02\x05\
    \x04\x12\x04$\0)\x01\n\n\n\x03\x05\x04\x01\x12\x03$\x05\x13\n\x11\n\x04\
    \x05\x04\x02\0\x12\x03%\x04\x1a\"\x04\x20?=\n\n\x0c\n\x05\x05\x04\x02\0\
    \x01\x12\x03%\x04\x15\n\x0c\n\x05\x05\x04\x02\0\x02\x12\x03%\x18\x19\n\
    \x11\n\x04\x05\x04\x02\x01\x12\x03&\x04\x1a\"\x04\x20?!\n\n\x0c\n\x05\
    \x05\x04\x02\x01\x01\x12\x03&\x04\x15\n\x0c\n\x05\x05\x04\x02\x01\x02\
    \x12\x03&\x18\x19\n\x12\n\x04\x05\x04\x02\x02\x12\x03'\x04\x1b\"\x05\x20\
    ?<=\n\n\x0c\n\x05\x05\x04\x02\x02\x01\x12\x03'\x04\x16\n\x0c\n\x05\x05\
    \x04\x02\x02\x02\x12\x03'\x19\x1a\n\x12\n\x04\x05\x04\x02\x03\x12\x03(\
    \x04\x1b\"\x05\x20?<!\n\n\x0c\n\x05\x05\x04\x02\x03\x01\x12\x03(\x04\x16\
    \n\x0c\n\x05\x05\x04\x02\x03\x02\x12\x03(\x19\x1a\n\n\n\x02\x05\x05\x12\
    \x04+\08\x01\n\n\n\x03\x05\x05\x01\x12\x03+\x05\x0f\nt\n\x04\x05\x05\x02\
    \0\x12\x03-\x04\x16\x1aF\x20UnicodeEscape\x20instead\x20of\x20Unicode\
    \x20because\x20Unicode\x20is\x20also\x20a\x20Flag\x20type\n\"\x1f\x20\\u\
    FFF,\x20\\uF0FF,\x20\\u{FFFF},\x20etc.\n\n\x0c\n\x05\x05\x05\x02\0\x01\
    \x12\x03-\x04\x11\n\x0c\n\x05\x05\x05\x02\0\x02\x12\x03-\x14\x15\n\x13\n\
    \x04\x05\x05\x02\x01\x12\x03.\x04\x0e\"\x06\x20\\000\n\n\x0c\n\x05\x05\
    \x05\x02\x01\x01\x12\x03.\x04\t\n\x0c\n\x05\x05\x05\x02\x01\x02\x12\x03.\
    \x0c\r\n\x1f\n\x04\x05\x05\x02\x02\x12\x03/\x04\x14\"\x12\x20\\xFF,\x20\
    \\xF0,\x20etc.\n\n\x0c\n\x05\x05\x05\x02\x02\x01\x12\x03/\x04\x0f\n\x0c\
    \n\x05\x05\x05\x02\x02\x02\x12\x03/\x12\x13\n\x1b\n\x04\x05\x05\x02\x03\
    \x12\x030\x04\x11\"\x0e\x20\\+,\x20\\\\,\x20etc.\n\n\x0c\n\x05\x05\x05\
    \x02\x03\x01\x12\x030\x04\x0c\n\x0c\n\x05\x05\x05\x02\x03\x02\x12\x030\
    \x0f\x10\n\x12\n\x04\x05\x05\x02\x04\x12\x031\x04\x10\"\x05\x20\\cI\n\n\
    \x0c\n\x05\x05\x05\x02\x04\x01\x12\x031\x04\x0b\n\x0c\n\x05\x05\x05\x02\
    \x04\x02\x12\x031\x0e\x0f\n\x11\n\x04\x05\x05\x02\x05\x12\x032\x04\x0c\"\
    \x04\x20\\t\n\n\x0c\n\x05\x05\x05\x02\x05\x01\x12\x032\x04\x07\n\x0c\n\
    \x05\x05\x05\x02\x05\x02\x12\x032\n\x0b\n\x11\n\x04\x05\x05\x02\x06\x12\
    \x033\x04\x10\"\x04\x20\\n\n\n\x0c\n\x05\x05\x05\x02\x06\x01\x12\x033\
    \x04\x0b\n\x0c\n\x05\x05\x05\x02\x06\x02\x12\x033\x0e\x0f\n\x11\n\x04\
    \x05\x05\x02\x07\x12\x034\x04\x14\"\x04\x20\\v\n\n\x0c\n\x05\x05\x05\x02\
    \x07\x01\x12\x034\x04\x0f\n\x0c\n\x05\x05\x05\x02\x07\x02\x12\x034\x12\
    \x13\n\x11\n\x04\x05\x05\x02\x08\x12\x035\x04\x11\"\x04\x20\\f\n\n\x0c\n\
    \x05\x05\x05\x02\x08\x01\x12\x035\x04\x0c\n\x0c\n\x05\x05\x05\x02\x08\
    \x02\x12\x035\x0f\x10\n\x11\n\x04\x05\x05\x02\t\x12\x036\x04\x17\"\x04\
    \x20\\r\n\n\x0c\n\x05\x05\x05\x02\t\x01\x12\x036\x04\x12\n\x0c\n\x05\x05\
    \x05\x02\t\x02\x12\x036\x15\x16\n\x11\n\x04\x05\x05\x02\n\x12\x037\x04\
    \x0e\"\x04\x20\\0\n\n\x0c\n\x05\x05\x05\x02\n\x01\x12\x037\x04\x08\n\x0c\
    \n\x05\x05\x05\x02\n\x02\x12\x037\x0b\r\n\n\n\x02\x05\x06\x12\x04:\0@\
    \x01\n\n\n\x03\x05\x06\x01\x12\x03:\x05\x17\n\x10\n\x04\x05\x06\x02\0\
    \x12\x03;\x04\x14\"\x03\x20(\n\n\x0c\n\x05\x05\x06\x02\0\x01\x12\x03;\
    \x04\x0f\n\x0c\n\x05\x05\x06\x02\0\x02\x12\x03;\x12\x13\n\x10\n\x04\x05\
    \x06\x02\x01\x12\x03<\x04\x15\"\x03\x20)\n\n\x0c\n\x05\x05\x06\x02\x01\
    \x01\x12\x03<\x04\x10\n\x0c\n\x05\x05\x06\x02\x01\x02\x12\x03<\x13\x14\n\
    =\n\x04\x05\x06\x02\x02\x12\x03=\x04\x12\"0\x20in\x20the\x20expression\
    \x20(?<name>ABC),\x20this\x20is\x20<name>\n\n\x0c\n\x05\x05\x06\x02\x02\
    \x01\x12\x03=\x04\r\n\x0c\n\x05\x05\x06\x02\x02\x02\x12\x03=\x10\x11\n\
    \x1b\n\x04\x05\x06\x02\x03\x12\x03>\x04\x19\"\x0e\x20\\1,\x20\\2,\x20etc\
    .\n\n\x0c\n\x05\x05\x06\x02\x03\x01\x12\x03>\x04\x14\n\x0c\n\x05\x05\x06\
    \x02\x03\x02\x12\x03>\x17\x18\n4\n\x04\x05\x06\x02\x04\x12\x03?\x04\x15\
    \"'\x20In\x20the\x20expression\x20(?:ABC),\x20this\x20is\x20?:\n\n\x0c\n\
    \x05\x05\x06\x02\x04\x01\x12\x03?\x04\x10\n\x0c\n\x05\x05\x06\x02\x04\
    \x02\x12\x03?\x13\x14\n\n\n\x02\x05\x07\x12\x04B\0R\x01\n\n\n\x03\x05\
    \x07\x01\x12\x03B\x05\x17\n\x19\n\x04\x05\x07\x02\0\x12\x03C\x04\x10\"\
    \x0c\x20[\x20in\x20[ABC]\n\n\x0c\n\x05\x05\x07\x02\0\x01\x12\x03C\x04\
    \x0b\n\x0c\n\x05\x05\x07\x02\0\x02\x12\x03C\x0e\x0f\n\x19\n\x04\x05\x07\
    \x02\x01\x12\x03D\x04\x11\"\x0c\x20]\x20in\x20[ABC]\n\n\x0c\n\x05\x05\
    \x07\x02\x01\x01\x12\x03D\x04\x0c\n\x0c\n\x05\x05\x07\x02\x01\x02\x12\
    \x03D\x0f\x10\n\x1a\n\x04\x05\x07\x02\x02\x12\x03E\x04\x14\"\r\x20^\x20i\
    n\x20[^ABC]\n\n\x0c\n\x05\x05\x07\x02\x02\x01\x12\x03E\x04\x0f\n\x0c\n\
    \x05\x05\x07\x02\x02\x02\x12\x03E\x12\x13\n\x1b\n\x04\x05\x07\x02\x03\
    \x12\x03F\x04\x15\"\x0e\x20ABC\x20in\x20[ABC]\n\n\x0c\n\x05\x05\x07\x02\
    \x03\x01\x12\x03F\x04\x10\n\x0c\n\x05\x05\x07\x02\x03\x02\x12\x03F\x13\
    \x14\n\x1b\n\x04\x05\x07\x02\x04\x12\x03G\x04\x11\"\x0e\x20A-Z\x20in\x20\
    [A-Z]\n\n\x0c\n\x05\x05\x07\x02\x04\x01\x12\x03G\x04\x0c\n\x0c\n\x05\x05\
    \x07\x02\x04\x02\x12\x03G\x0f\x10\n\x10\n\x04\x05\x07\x02\x05\x12\x03H\
    \x04\x0c\"\x03\x20.\n\n\x0c\n\x05\x05\x07\x02\x05\x01\x12\x03H\x04\x07\n\
    \x0c\n\x05\x05\x07\x02\x05\x02\x12\x03H\n\x0b\n\x11\n\x04\x05\x07\x02\
    \x06\x12\x03I\x04\r\"\x04\x20\\w\n\n\x0c\n\x05\x05\x07\x02\x06\x01\x12\
    \x03I\x04\x08\n\x0c\n\x05\x05\x07\x02\x06\x02\x12\x03I\x0b\x0c\n\x11\n\
    \x04\x05\x07\x02\x07\x12\x03J\x04\x10\"\x04\x20\\W\n\n\x0c\n\x05\x05\x07\
    \x02\x07\x01\x12\x03J\x04\x0b\n\x0c\n\x05\x05\x07\x02\x07\x02\x12\x03J\
    \x0e\x0f\n\x11\n\x04\x05\x07\x02\x08\x12\x03K\x04\x0e\"\x04\x20\\d\n\n\
    \x0c\n\x05\x05\x07\x02\x08\x01\x12\x03K\x04\t\n\x0c\n\x05\x05\x07\x02\
    \x08\x02\x12\x03K\x0c\r\n\x11\n\x04\x05\x07\x02\t\x12\x03L\x04\x11\"\x04\
    \x20\\D\n\n\x0c\n\x05\x05\x07\x02\t\x01\x12\x03L\x04\x0c\n\x0c\n\x05\x05\
    \x07\x02\t\x02\x12\x03L\x0f\x10\n\x11\n\x04\x05\x07\x02\n\x12\x03M\x04\
    \x14\"\x04\x20\\s\n\n\x0c\n\x05\x05\x07\x02\n\x01\x12\x03M\x04\x0e\n\x0c\
    \n\x05\x05\x07\x02\n\x02\x12\x03M\x11\x13\n\x11\n\x04\x05\x07\x02\x0b\
    \x12\x03N\x04\x17\"\x04\x20\\S\n\n\x0c\n\x05\x05\x07\x02\x0b\x01\x12\x03\
    N\x04\x11\n\x0c\n\x05\x05\x07\x02\x0b\x02\x12\x03N\x14\x16\n:\n\x04\x05\
    \x07\x02\x0c\x12\x03O\x04\x1f\"-\x20\\p{...}\x20include\x20unicode\x20ca\
    tegory\x20and\x20script\n\n\x0c\n\x05\x05\x07\x02\x0c\x01\x12\x03O\x04\
    \x19\n\x0c\n\x05\x05\x07\x02\x0c\x02\x12\x03O\x1c\x1e\n\x16\n\x04\x05\
    \x07\x02\r\x12\x03P\x04\"\"\t\x20\\P{...}\n\n\x0c\n\x05\x05\x07\x02\r\
    \x01\x12\x03P\x04\x1c\n\x0c\n\x05\x05\x07\x02\r\x02\x12\x03P\x1f!\n\x16\
    \n\x04\x05\x07\x02\x0e\x12\x03Q\x04\x15\"\t\x20(?>...)\n\n\x0c\n\x05\x05\
    \x07\x02\x0e\x01\x12\x03Q\x04\x0f\n\x0c\n\x05\x05\x07\x02\x0e\x02\x12\
    \x03Q\x12\x14\n\n\n\x02\x05\x08\x12\x04T\0^\x01\n\n\n\x03\x05\x08\x01\
    \x12\x03T\x05\x0e\n\x0b\n\x04\x05\x08\x02\0\x12\x03U\x04\r\n\x0c\n\x05\
    \x05\x08\x02\0\x01\x12\x03U\x04\x08\n\x0c\n\x05\x05\x08\x02\0\x02\x12\
    \x03U\x0b\x0c\n\x0b\n\x04\x05\x08\x02\x01\x12\x03V\x04\x15\n\x0c\n\x05\
    \x05\x08\x02\x01\x01\x12\x03V\x04\x10\n\x0c\n\x05\x05\x08\x02\x01\x02\
    \x12\x03V\x13\x14\n\x0b\n\x04\x05\x08\x02\x02\x12\x03W\x04\x1b\n\x0c\n\
    \x05\x05\x08\x02\x02\x01\x12\x03W\x04\x16\n\x0c\n\x05\x05\x08\x02\x02\
    \x02\x12\x03W\x19\x1a\n\x0b\n\x04\x05\x08\x02\x03\x12\x03X\x04\x0f\n\x0c\
    \n\x05\x05\x08\x02\x03\x01\x12\x03X\x04\n\n\x0c\n\x05\x05\x08\x02\x03\
    \x02\x12\x03X\r\x0e\n\x0b\n\x04\x05\x08\x02\x04\x12\x03Y\x04\x17\n\x0c\n\
    \x05\x05\x08\x02\x04\x01\x12\x03Y\x04\x12\n\x0c\n\x05\x05\x08\x02\x04\
    \x02\x12\x03Y\x15\x16\n\x0b\n\x04\x05\x08\x02\x05\x12\x03Z\x04\x12\n\x0c\
    \n\x05\x05\x08\x02\x05\x01\x12\x03Z\x04\r\n\x0c\n\x05\x05\x08\x02\x05\
    \x02\x12\x03Z\x10\x11\n\x0b\n\x04\x05\x08\x02\x06\x12\x03[\x04\x13\n\x0c\
    \n\x05\x05\x08\x02\x06\x01\x12\x03[\x04\x0e\n\x0c\n\x05\x05\x08\x02\x06\
    \x02\x12\x03[\x11\x12\n\x0b\n\x04\x05\x08\x02\x07\x12\x03\\\x04\x0f\n\
    \x0c\n\x05\x05\x08\x02\x07\x01\x12\x03\\\x04\n\n\x0c\n\x05\x05\x08\x02\
    \x07\x02\x12\x03\\\r\x0e\n\x0b\n\x04\x05\x08\x02\x08\x12\x03]\x04\x17\n\
    \x0c\n\x05\x05\x08\x02\x08\x01\x12\x03]\x04\x12\n\x0c\n\x05\x05\x08\x02\
    \x08\x02\x12\x03]\x15\x16\n\n\n\x02\x04\0\x12\x04`\0o\x01\n\n\n\x03\x04\
    \0\x01\x12\x03`\x08\r\n\x0b\n\x04\x04\0\x02\0\x12\x03a\x04\x15\n\x0c\n\
    \x05\x04\0\x02\0\x05\x12\x03a\x04\n\n\x0c\n\x05\x04\0\x02\0\x01\x12\x03a\
    \x0b\x10\n\x0c\n\x05\x04\0\x02\0\x03\x12\x03a\x13\x14\n\x0b\n\x04\x04\0\
    \x02\x01\x12\x03b\x04\x17\n\x0c\n\x05\x04\0\x02\x01\x06\x12\x03b\x04\r\n\
    \x0c\n\x05\x04\0\x02\x01\x01\x12\x03b\x0e\x12\n\x0c\n\x05\x04\0\x02\x01\
    \x03\x12\x03b\x15\x16\n\x0c\n\x04\x04\0\x08\0\x12\x04d\x04n\x05\n\x0c\n\
    \x05\x04\0\x08\0\x01\x12\x03d\n\x12\n\x0b\n\x04\x04\0\x02\x02\x12\x03e\
    \x08\x1b\n\x0c\n\x05\x04\0\x02\x02\x06\x12\x03e\x08\x10\n\x0c\n\x05\x04\
    \0\x02\x02\x01\x12\x03e\x11\x15\n\x0c\n\x05\x04\0\x02\x02\x03\x12\x03e\
    \x18\x1a\n\x0b\n\x04\x04\0\x02\x03\x12\x03f\x08+\n\x0c\n\x05\x04\0\x02\
    \x03\x06\x12\x03f\x08\x18\n\x0c\n\x05\x04\0\x02\x03\x01\x12\x03f\x19%\n\
    \x0c\n\x05\x04\0\x02\x03\x03\x12\x03f(*\n\x0b\n\x04\x04\0\x02\x04\x12\
    \x03g\x087\n\x0c\n\x05\x04\0\x02\x04\x06\x12\x03g\x08\x1e\n\x0c\n\x05\
    \x04\0\x02\x04\x01\x12\x03g\x1f1\n\x0c\n\x05\x04\0\x02\x04\x03\x12\x03g4\
    6\n\x0b\n\x04\x04\0\x02\x05\x12\x03h\x08\x1f\n\x0c\n\x05\x04\0\x02\x05\
    \x06\x12\x03h\x08\x12\n\x0c\n\x05\x04\0\x02\x05\x01\x12\x03h\x13\x19\n\
    \x0c\n\x05\x04\0\x02\x05\x03\x12\x03h\x1c\x1e\n\x0b\n\x04\x04\0\x02\x06\
    \x12\x03i\x08\x1e\n\x0c\n\x05\x04\0\x02\x06\x05\x12\x03i\x08\x0e\n\x0c\n\
    \x05\x04\0\x02\x06\x01\x12\x03i\x0f\x18\n\x0c\n\x05\x04\0\x02\x06\x03\
    \x12\x03i\x1b\x1d\n\x0b\n\x04\x04\0\x02\x07\x12\x03j\x08'\n\x0c\n\x05\
    \x04\0\x02\x07\x06\x12\x03j\x08\x16\n\x0c\n\x05\x04\0\x02\x07\x01\x12\
    \x03j\x17!\n\x0c\n\x05\x04\0\x02\x07\x03\x12\x03j$&\n\x0b\n\x04\x04\0\
    \x02\x08\x12\x03k\x08\x1f\n\x0c\n\x05\x04\0\x02\x08\x06\x12\x03k\x08\x12\
    \n\x0c\n\x05\x04\0\x02\x08\x01\x12\x03k\x13\x19\n\x0c\n\x05\x04\0\x02\
    \x08\x03\x12\x03k\x1c\x1e\n\x0b\n\x04\x04\0\x02\t\x12\x03l\x08)\n\x0c\n\
    \x05\x04\0\x02\t\x06\x12\x03l\x08\x1a\n\x0c\n\x05\x04\0\x02\t\x01\x12\
    \x03l\x1b#\n\x0c\n\x05\x04\0\x02\t\x03\x12\x03l&(\n\x0b\n\x04\x04\0\x02\
    \n\x12\x03m\x08/\n\x0c\n\x05\x04\0\x02\n\x06\x12\x03m\x08\x1a\n\x0c\n\
    \x05\x04\0\x02\n\x01\x12\x03m\x1b)\n\x0c\n\x05\x04\0\x02\n\x03\x12\x03m,\
    .\n\n\n\x02\x05\t\x12\x04q\0y\x01\n\n\n\x03\x05\t\x01\x12\x03q\x05\x16\n\
    \x0b\n\x04\x05\t\x02\0\x12\x03r\x04\x0f\n\x0c\n\x05\x05\t\x02\0\x01\x12\
    \x03r\x04\n\n\x0c\n\x05\x05\t\x02\0\x02\x12\x03r\r\x0e\n\x0b\n\x04\x05\t\
    \x02\x01\x12\x03s\x04\x13\n\x0c\n\x05\x05\t\x02\x01\x01\x12\x03s\x04\x0e\
    \n\x0c\n\x05\x05\t\x02\x01\x02\x12\x03s\x11\x12\n\x0b\n\x04\x05\t\x02\
    \x02\x12\x03t\x04\r\n\x0c\n\x05\x05\t\x02\x02\x01\x12\x03t\x04\x08\n\x0c\
    \n\x05\x05\t\x02\x02\x02\x12\x03t\x0b\x0c\n\x0b\n\x04\x05\t\x02\x03\x12\
    \x03u\x04\r\n\x0c\n\x05\x05\t\x02\x03\x01\x12\x03u\x04\x08\n\x0c\n\x05\
    \x05\t\x02\x03\x02\x12\x03u\x0b\x0c\n\x0b\n\x04\x05\t\x02\x04\x12\x03v\
    \x04\x0f\n\x0c\n\x05\x05\t\x02\x04\x01\x12\x03v\x04\n\n\x0c\n\x05\x05\t\
    \x02\x04\x02\x12\x03v\r\x0e\n\x0b\n\x04\x05\t\x02\x05\x12\x03w\x04\x0c\n\
    \x0c\n\x05\x05\t\x02\x05\x01\x12\x03w\x04\x07\n\x0c\n\x05\x05\t\x02\x05\
    \x02\x12\x03w\n\x0b\n\x0b\n\x04\x05\t\x02\x06\x12\x03x\x04\r\n\x0c\n\x05\
    \x05\t\x02\x06\x01\x12\x03x\x04\x08\n\x0c\n\x05\x05\t\x02\x06\x02\x12\
    \x03x\x0b\x0c\n\n\n\x02\x04\x01\x12\x04{\0\x7f\x01\n\n\n\x03\x04\x01\x01\
    \x12\x03{\x08\x12\n\x0b\n\x04\x04\x01\x02\0\x12\x03|\x04\x13\n\x0c\n\x05\
    \x04\x01\x02\0\x05\x12\x03|\x04\n\n\x0c\n\x05\x04\x01\x02\0\x01\x12\x03|\
    \x0b\x0e\n\x0c\n\x05\x04\x01\x02\0\x03\x12\x03|\x11\x12\n\x0b\n\x04\x04\
    \x01\x02\x01\x12\x03}\x04\x1c\n\x0c\n\x05\x04\x01\x02\x01\x04\x12\x03}\
    \x04\x0c\n\x0c\n\x05\x04\x01\x02\x01\x06\x12\x03}\r\x12\n\x0c\n\x05\x04\
    \x01\x02\x01\x01\x12\x03}\x13\x19\n\x0c\n\x05\x04\x01\x02\x01\x03\x12\
    \x03}\x1a\x1b\n\x0b\n\x04\x04\x01\x02\x02\x12\x03~\x04&\n\x0c\n\x05\x04\
    \x01\x02\x02\x04\x12\x03~\x04\x0c\n\x0c\n\x05\x04\x01\x02\x02\x06\x12\
    \x03~\r\x17\n\x0c\n\x05\x04\x01\x02\x02\x01\x12\x03~\x18#\n\x0c\n\x05\
    \x04\x01\x02\x02\x03\x12\x03~$%\n\x0c\n\x02\x04\x02\x12\x06\x81\x01\0\
    \x86\x01\x01\n\x0b\n\x03\x04\x02\x01\x12\x04\x81\x01\x08\x0c\n\x0c\n\x04\
    \x04\x02\x02\0\x12\x04\x82\x01\x04\x14\n\r\n\x05\x04\x02\x02\0\x05\x12\
    \x04\x82\x01\x04\n\n\r\n\x05\x04\x02\x02\0\x01\x12\x04\x82\x01\x0b\x0f\n\
    \r\n\x05\x04\x02\x02\0\x03\x12\x04\x82\x01\x12\x13\n\x0c\n\x04\x04\x02\
    \x02\x01\x12\x04\x83\x01\x04#\n\r\n\x05\x04\x02\x02\x01\x06\x12\x04\x83\
    \x01\x04\x15\n\r\n\x05\x04\x02\x02\x01\x01\x12\x04\x83\x01\x16\x1e\n\r\n\
    \x05\x04\x02\x02\x01\x03\x12\x04\x83\x01!\"\n\x0c\n\x04\x04\x02\x02\x02\
    \x12\x04\x84\x01\x04\x1a\n\r\n\x05\x04\x02\x02\x02\x05\x12\x04\x84\x01\
    \x04\t\n\r\n\x05\x04\x02\x02\x02\x01\x12\x04\x84\x01\n\x15\n\r\n\x05\x04\
    \x02\x02\x02\x03\x12\x04\x84\x01\x18\x19\n\x0c\n\x04\x04\x02\x02\x03\x12\
    \x04\x85\x01\x04\x1e\n\r\n\x05\x04\x02\x02\x03\x06\x12\x04\x85\x01\x04\
    \x0e\n\r\n\x05\x04\x02\x02\x03\x01\x12\x04\x85\x01\x0f\x19\n\r\n\x05\x04\
    \x02\x02\x03\x03\x12\x04\x85\x01\x1c\x1d\n\x0c\n\x02\x04\x03\x12\x06\x88\
    \x01\0\x91\x01\x01\n\x0b\n\x03\x04\x03\x01\x12\x04\x88\x01\x08\x12\n\x0c\
    \n\x04\x04\x03\x02\0\x12\x04\x89\x01\x04\x14\n\r\n\x05\x04\x03\x02\0\x05\
    \x12\x04\x89\x01\x04\n\n\r\n\x05\x04\x03\x02\0\x01\x12\x04\x89\x01\x0b\
    \x0f\n\r\n\x05\x04\x03\x02\0\x03\x12\x04\x89\x01\x12\x13\n\x9e\x01\n\x04\
    \x04\x03\x08\0\x12\x06\x8c\x01\x04\x90\x01\x05\x1a\x8d\x01\x20A\x20relev\
    ant\x20entity\x20for\x20an\x20annotation\x20can\x20be\x20either\x20a\x20\
    token\x20or\x20an\x20expression,\x20or\x20alternatively,\x20\n\x20a\x20m\
    odule\x20can\x20choose\x20just\x20to\x20attach\x20a\x20string\n\n\r\n\
    \x05\x04\x03\x08\0\x01\x12\x04\x8c\x01\n\x19\n\x0c\n\x04\x04\x03\x02\x01\
    \x12\x04\x8d\x01\x08\x1a\n\r\n\x05\x04\x03\x02\x01\x05\x12\x04\x8d\x01\
    \x08\x0e\n\r\n\x05\x04\x03\x02\x01\x01\x12\x04\x8d\x01\x0f\x15\n\r\n\x05\
    \x04\x03\x02\x01\x03\x12\x04\x8d\x01\x18\x19\n\x0c\n\x04\x04\x03\x02\x02\
    \x12\x04\x8e\x01\x08\x18\n\r\n\x05\x04\x03\x02\x02\x06\x12\x04\x8e\x01\
    \x08\r\n\r\n\x05\x04\x03\x02\x02\x01\x12\x04\x8e\x01\x0e\x13\n\r\n\x05\
    \x04\x03\x02\x02\x03\x12\x04\x8e\x01\x16\x17\n\x0c\n\x04\x04\x03\x02\x03\
    \x12\x04\x8f\x01\x08\"\n\r\n\x05\x04\x03\x02\x03\x06\x12\x04\x8f\x01\x08\
    \x12\n\r\n\x05\x04\x03\x02\x03\x01\x12\x04\x8f\x01\x13\x1d\n\r\n\x05\x04\
    \x03\x02\x03\x03\x12\x04\x8f\x01\x20!\n\x0c\n\x02\x04\x04\x12\x06\x93\
    \x01\0\x97\x01\x01\n\x0b\n\x03\x04\x04\x01\x12\x04\x93\x01\x08\x0e\n\x0c\
    \n\x04\x04\x04\x02\0\x12\x04\x94\x01\x04\x16\n\r\n\x05\x04\x04\x02\0\x05\
    \x12\x04\x94\x01\x04\n\n\r\n\x05\x04\x04\x02\0\x01\x12\x04\x94\x01\x0b\
    \x11\n\r\n\x05\x04\x04\x02\0\x03\x12\x04\x94\x01\x14\x15\n\x0c\n\x04\x04\
    \x04\x02\x01\x12\x04\x95\x01\x04(\n\r\n\x05\x04\x04\x02\x01\x04\x12\x04\
    \x95\x01\x04\x0c\n\r\n\x05\x04\x04\x02\x01\x06\x12\x04\x95\x01\r\x17\n\r\
    \n\x05\x04\x04\x02\x01\x01\x12\x04\x95\x01\x18#\n\r\n\x05\x04\x04\x02\
    \x01\x03\x12\x04\x95\x01&'\n\x0c\n\x04\x04\x04\x02\x02\x12\x04\x96\x01\
    \x04\x14\n\r\n\x05\x04\x04\x02\x02\x05\x12\x04\x96\x01\x04\t\n\r\n\x05\
    \x04\x04\x02\x02\x01\x12\x04\x96\x01\n\x0f\n\r\n\x05\x04\x04\x02\x02\x03\
    \x12\x04\x96\x01\x12\x13\n\x0c\n\x02\x04\x05\x12\x06\x99\x01\0\x9c\x01\
    \x01\n\x0b\n\x03\x04\x05\x01\x12\x04\x99\x01\x08\x12\n\x0c\n\x04\x04\x05\
    \x02\0\x12\x04\x9a\x01\x04\x12\n\r\n\x05\x04\x05\x02\0\x06\x12\x04\x9a\
    \x01\x04\x08\n\r\n\x05\x04\x05\x02\0\x01\x12\x04\x9a\x01\t\r\n\r\n\x05\
    \x04\x05\x02\0\x03\x12\x04\x9a\x01\x10\x11\n\x0c\n\x04\x04\x05\x02\x01\
    \x12\x04\x9b\x01\x04\x20\n\r\n\x05\x04\x05\x02\x01\x04\x12\x04\x9b\x01\
    \x04\x0c\n\r\n\x05\x04\x05\x02\x01\x06\x12\x04\x9b\x01\r\x13\n\r\n\x05\
    \x04\x05\x02\x01\x01\x12\x04\x9b\x01\x14\x1b\n\r\n\x05\x04\x05\x02\x01\
    \x03\x12\x04\x9b\x01\x1e\x1f\n\x0c\n\x02\x04\x06\x12\x06\x9e\x01\0\xa3\
    \x01\x01\n\x0b\n\x03\x04\x06\x01\x12\x04\x9e\x01\x08\x18\n\x0c\n\x04\x04\
    \x06\x02\0\x12\x04\x9f\x01\x04\x1a\n\r\n\x05\x04\x06\x02\0\x05\x12\x04\
    \x9f\x01\x04\n\n\r\n\x05\x04\x06\x02\0\x01\x12\x04\x9f\x01\x0b\x15\n\r\n\
    \x05\x04\x06\x02\0\x03\x12\x04\x9f\x01\x18\x19\n\x0c\n\x04\x04\x06\x02\
    \x01\x12\x04\xa0\x01\x04\x14\n\r\n\x05\x04\x06\x02\x01\x05\x12\x04\xa0\
    \x01\x04\n\n\r\n\x05\x04\x06\x02\x01\x01\x12\x04\xa0\x01\x0b\x0f\n\r\n\
    \x05\x04\x06\x02\x01\x03\x12\x04\xa0\x01\x12\x13\n\x0c\n\x04\x04\x06\x02\
    \x02\x12\x04\xa1\x01\x04\x1a\n\r\n\x05\x04\x06\x02\x02\x05\x12\x04\xa1\
    \x01\x04\t\n\r\n\x05\x04\x06\x02\x02\x01\x12\x04\xa1\x01\n\x15\n\r\n\x05\
    \x04\x06\x02\x02\x03\x12\x04\xa1\x01\x18\x19\n\x0c\n\x04\x04\x06\x02\x03\
    \x12\x04\xa2\x01\x04#\n\r\n\x05\x04\x06\x02\x03\x06\x12\x04\xa2\x01\x04\
    \x15\n\r\n\x05\x04\x06\x02\x03\x01\x12\x04\xa2\x01\x16\x1e\n\r\n\x05\x04\
    \x06\x02\x03\x03\x12\x04\xa2\x01!\"b\x06proto3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
